# Top 300 LeetCode Problems Solving

<p style="text-align: justify; font-family: Verdana">
In this repository I will keep the top 300 LeetCode problems that I have solved in LeetCode. I will keep all the solved problems here topicwise. I will try to solve problems every day and update here.
</p>

## ðŸ“˜ Problem List

### ðŸ”¹ Array

#### ðŸŸ¢ Problem 01: [Moving Zeroes](https://leetcode.com/problems/move-zeroes/)
**Description:**  
Given an integer array `nums`, move all `0`'s to the end while maintaining the relative order of the non-zero elements.  
**Note:** You must do this **in-place** without making a copy of the array.

#### ðŸŸ¢ Problem 02: [Majority Elements](https://leetcode.com/problems/majority-element/)
**Description:**  
Given an array `nums` of size `n`, return the majority element. <br>
The majority element is the element that appears more than `âŒŠn / 2âŒ‹` times. You may assume that the majority element always exists in the array. <br>
Follow-up: Could you solve the problem in linear time and in `O(1)` space? <br>
`This problem is solved by Boyer-Moore voting algorithm`

#### ðŸŸ¢ Problem 03: [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)
**Description:**  
<<<<<<< HEAD
Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in `nums`.
=======
Given an array `nums` of size `n`, return the majority element. <br>
The majority element is the element that appears more than `âŒŠn / 2âŒ‹` times. You may assume that the majority element always exists in the array. <br>
Follow-up: Could you solve the problem in linear time and in `O(1)` space? <br>
`This problem is solved by Boyer-Moore voting algorithm`
>>>>>>> c0ac6d31f8db250a30b347d22a233d642395c3bc

---

### ðŸ”¹ Two Pointer

#### ðŸŸ¢ Problem 01: [Two Sum](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)
**Description:**  
Given a `1-indexed` array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers `[index1]` and numbers `[index2]` where `1 <= index1 < index2 <= numbers.length`.

Return the indices of the two numbers, `index1` and `index2`, added by one as an integer array `[index1, index2]` of length `2`.
